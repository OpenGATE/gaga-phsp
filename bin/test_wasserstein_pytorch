#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import click
import numpy as np
from matplotlib import pyplot as plt
import torch

def wasserstein1D(x, y, p=2):
    sx, indices = torch.sort(x)
    sy, indices = torch.sort(y)
    z = (sx-sy)
    return torch.sum(torch.pow(torch.abs(z), p))/len(z)
    
    
def sliced_wasserstein(x, y, l, p=2):
    ndim = len(x[0])
    # directions: matrix [ndim X l]
    directions = np.random.randn(ndim, l)
    directions /= np.linalg.norm(directions, axis=0)

    # send to gpu if possible
    dtypef = torch.FloatTensor
    if x.is_cuda:
        dtypef = torch.cuda.FloatTensor
    directions = torch.from_numpy(directions).type(dtypef)

    # Projection (Radon) x = [n X ndim], px = [n]
    px = torch.matmul(x,directions)
    py = torch.matmul(y,directions)

    # sum wasserstein1D over all directions
    d = 0
    for i in range(l):
        lx = px[:,i]
        ly = py[:,i]
        d += wasserstein1D(lx, ly, p)
    d = d/l
    return d
    

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])
@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('--n', '-n', default=1e4, help='Number of samples to generate')
@click.option('--l', '-l', default=1e2, help='Number of projections')
@click.option('--plot/--no-plot', default=False)
def test_wasserstein_pytorch(n, l, plot):
    '''
    \b
    Compute sliced Wasserstein distance between nD Gaussian distributions
    '''

    # Nb of samples
    n = int(n)
    np.random.seed(0)

    # Input data (3D Gaussian)
    mean = [0, 0, 0]
    cov = [[1, 0, 0], [0, 10, 0], [0, 0, 1]]
    x = np.random.multivariate_normal(mean, cov, n)

    mean = [0.5, 0, 0]
    cov = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    y = np.random.multivariate_normal(mean, cov, n)

    # plot (2D only)
    if (plot):
        plt.plot(x[:,0], x[:,1], '.', alpha=0.5)
        plt.plot(y[:,0], y[:,1], '.', alpha=0.5)
        plt.axis('equal')
        plt.show()

    # set to pytorch
    dtypef = torch.FloatTensor
    if (torch.cuda.is_available()):
        dtypef = torch.cuda.FloatTensor
    x = torch.from_numpy(x).type(dtypef)
    y = torch.from_numpy(y).type(dtypef)
    
    l = int(l)
    d = sliced_wasserstein(x,y,l)
    print(d.data.cpu().numpy())
    
    

# --------------------------------------------------------------------------
if __name__ == '__main__':
    test_wasserstein_pytorch()

